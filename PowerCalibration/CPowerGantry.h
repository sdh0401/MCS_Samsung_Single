#pragma once
#include "Thread.h"
#include "GlobalDefine.h"
#include "Wmx3MotorDefine.h"
#include <WMX3Api.h>
#include <CompensationApi.h>
#include <EventApi.h>

using namespace wmx3Api;

class CPowerGantry// : public CThread
{
public:
	CPowerGantry();
	~CPowerGantry();
	long GetAxisMap(CString strAxis);
	bool Lock(CString strAxis);
	bool Unlock(CString strAxis);
	bool Release(CString strAxis);
	bool Lock(long AxisNo);
	bool Unlock(long AxisNo);
	bool Release(long AxisNo);
	long GetAxisNullError(CString strAxis);
	long GetTimeOutError(CString strAxis);
	long GetMinusLimitError(CString strAxis); 
	long GetPlusLimitError(CString strAxis);
	long GetServoOnError(CString strAxis);
	void SetShortDist(CString strAxis, long index, double ShortDist);
	void SetShortDistVel(CString strAxis, long index, double ShortVel);
	void SetShortDistAccDec(CString strAxis, long index, double ShortAccDec);
	void SetMoveProfile(CString strAxis, WMX3_AXIS_POSCOMMANDPROFILE profile);
	void SetTable(long Table);
	long GetTable();
	double GetDryRunZHeightOffset();
	void InitializeValue();
	void SetInsertByZ(long Gantry, double InsertByZ);
	double GetInsertByZ(long Gantry);
	void SetPusherByZ(long Gantry, double PusherByZ);
	double GetPusherByZ(long Gantry);
	void SetStandByZ(long Gantry, double StandByZ);
	double GetStandByZ(long Gantry);
	void SetStandByR(long Gantry, double StandByR);
	double GetStandByR(long Gantry);
	void SetMaxZTorqueLimit(long Gantry, long Head, double MaxTorqueLimit);
	double GetMaxZTorqueLimit(long Gantry, long Head);
	Point_XY ReadGantryPosition(long Gantry);
	void ReadAllPosition(long Gantry);
	double ReadPosition(long AxisNo);
	void SetWriteDisk(bool bWrite);
	void SetUseZAxis(CString strZAxis, bool bUse);
	void SetUseRAxis(CString strZAxis, bool bUse);

	CString GetAxisX(long Gantry);
	CString GetAxisY1(long Gantry);
	CString GetAxisY2(long Gantry);
	CString GetConvName(long Conveyor);
	CString GetPusherZName(long Conveyor);
	CString GetRAxisFromHeadNo(long Gantry, long HeadNo);
	CString GetZAxisFromHeadNo(long Gantry, long HeadNo);
	CString GetHeadToRotateAxis(long Gantry, CString HeadNo);
	CString GetRotateAxisToHead(long Gantry, CString RotateNo);

	long SetInitializeEnd(CString strAxis, bool bEnd);
	long OneOriginSearch(CString strAxis, double forceOffset);
	long GetAllAxisHomingInComplete();
	bool IsAllAxisHomingComplete();
	bool IsAllZAxisHomingComplete();
	bool IsAllRAxisHomingComplete();
	bool IsOneAxisHomingComplete(INT_PTR indx);
	bool IsOneZAxisHomingComplete(INT_PTR indx);
	bool IsOneRAxisHomingComplete(INT_PTR indx);
	bool IsOneAxisHomingComplete(CString strAxis);
	long IsWaitOnePos(CString strAxis, double Cmd, double Inpos, long TimeOut, bool UseSendAlarm = true);
	bool IsAllEventAvailable(long* Err, bool UseSendAlarm = true);
	long GantryEventEnable(long Gantry);
	bool GetEventInfo(long Eventid, EventControl::Event* EventInfo);
	bool IsGantryEvent(long Gantry, long Eventid);
	bool IsOneAxisHomingFail(CString strAxis);
	bool IsOneAxisHomingFail(INT_PTR indx);
	bool IsAllAxisHomingFail();

	long WaitAllZIdle(long Gantry, long TimeOut);
	long WaitAllRIdle(long Gantry, long TimeOut);
	long WaitGantryIdle(long Gantry, long TimeOut);
	long WaitOneIdle(CString strAxis, long TimeOut);
	long WaitOneMotion(CString strAxis, double CmdPos, long TimeOut);
	long WaitOnePosSet(CString strAxis, double CmdPos, long TimeOut);
	long WaitOneInPos(CString strAxis, double CmdPos, long TimeOut);
	long WaitOneDelayedPosSet(CString strAxis, double CmdPos, long TimeOut, bool UseSendAlarm = true);
	long SetOnePosSet(CString strAxis, double PosSetWidth);
	long SetOneInPos(CString strAxis, double PosSetWidth);
	long SetOneDelayedPosSet(CString strAxis, double PosSetWidth, long ms);
	long StopOne(CString strAxis);
	long StopOne(CString strAxis, double dec);
	long StartOneJog(CString strAxis, JogInfo jogInfo);
	long StartOnePosition(CString strAxis, double Cmd);
	long StartOnePositionSkipLimitCheck(CString strAxis, double Cmd);
	long StartOne2StepPosition(CString strAxis, double Cmd, double Cmd2nd);
	long StartOnePositionWithoutSlave(CString strAxis, double Cmd);
	long StartOnePositionX(CString strAxis, double Cmd, double Ratio);
	long StartOnePositionY(CString strAxis, double Cmd, double Ratio);
	long StartOneMove(CString strAxis, double Cmd);
	long StartOneMoveWithoutSlave(CString strAxis, double Cmd);
	long StartOneTeachMove(CString strAxis, double Cmd);
	void SetOneRatio(CString strAxis, double Ratio);
	void SetOne2ndRatio(CString strAxis, double Ratio2nd);
	void InitOneRatio(CString strAxis);
	bool ServoOnWithAlarmClear(CString strAxis);
	 
	void TryAlarmClearAllAxis();
	bool IsAlarmClearAllAxis(long *clearFailAxisNo);
	void TrayServoOnAllAxis();
	bool IsServoOnAllAxis(long* servoOnFailAxisNo);
	bool CheckOverloadAlarm();
	long ServoAllOn();
	long ServoAllOff();
	long ServoAllOffWithoutConvAxis();
	long SetSyncMasterSlave();
	bool IsUseSlaveAxis(CString strAxis);
	bool IsGantryAxis(CString strAxis);
	long RestoreY1Y2Different();
	long RestoreY1Y2DifferentByPosCmd();
	long GetAlarmCodeOverload();

	bool AlarmClear(CString strAxis);
	bool ClearSlaveAmpAlarm(CString strAxis);
	bool CheckAmpAlarm(CString strAxis);
	bool CheckSlaveAmpAlarm(CString strAxis);
	bool CheckServoOn(CString strAxis);
	bool CheckSlaveServoOn(CString strAxis);
	long GetSlaveAxisIndex(CString strAxis);
	long GetAxisID(CString strAxis);
	long GetSlaveAxisSlaveID(CString strAxis);
	bool ServoOn(CString strAxis);
	bool SlaveServoOn(CString strAxis);
	bool ServoOff(CString strAxis);
	bool SlaveServoOff(CString strAxis);
	double GetUnResol(CString strAxis);
	double ReadOnePosition(CString strAxis);
	double ReadCommandPosition(CString strAxis);
	double ReadOneCommandVelocity(CString strAxis);
	double ReadProfileTargetPosition(CString strAxis);
	long WriteOnePosition(CString strAxis, double Position);
	double ReadMotorActualPosition(CString strAxis);
	double ReadActualTorque(CString strAxis);
	double Read1DCompensationData(CString strAxis);
	double Read2DCompensationData(CString strAxis);
	double ReadVirtualPositiveLimit(CString strAxis);
	double ReadVirtualNegativeLimit(CString strAxis);
	bool IsNegativeLimitSwitchOn(CString strAxis);
	bool IsPositiveLimitSwitchOn(CString strAxis);
	long GetOneOnlyIdle(CString strAxis);
	long StartMultiPosition(SomeTarget Target);
	long StartMultiPosition(long Target);
	long StartMultiPosition(Point_XY Linear, Point_XY StartCenter, Point_XY EndCenter, Point_XY Goal);
	long WaitMultiMotion(SomeTarget Target);
	long WaitMultiMotion(long TimeOut);
	long WaitMultiPosSet(SomeTarget TimeOut);
	long WaitMultiPosSet(long TimeOut);
	long WaitMultiDelayedPosSet(SomeTarget Target);
	long WaitMultiDelayedPosSet(long TimeOut);
	void ReadMultiPosition();

	long StartMultiPositionR(SomeTarget Target);
	long StartMultiPositionR(long Target);
	long WaitMultiMotionR(SomeTarget Target);
	long WaitMultiMotionR(long TimeOut);
	long WaitMultiRPosSet(SomeTarget TimeOut);
	long WaitMultiRPosSet(long TimeOut);
	long WaitMultiDelayedRPosSet(SomeTarget Target);
	long WaitMultiDelayedRPosSet(long TimeOut);
	void ReadMultiPositionR();

	long Disable1DCompensation();
	long Enable1DCompensation();
	long Set1DCompensation();

	long Disable2DCompensation(long Channel);
	long Enable2DCompensation(long Channel);
	long Set2DCompensation(long Gantry);
	long Set2DCompensation(long Gantry, long MarkXCount, long MarkYCount);

	long PauseGantry();
	long ResumeGantry();
	long ReleaseGantry();
	void AddZAxis(CString pStrAxis);
	bool RemoveZAxis(INT_PTR indx);
	INT_PTR GetZAxisCount();
	void AddAllZAxis();
	CString GetZAxisByIndex(INT_PTR indx);
	long GetZAxisIndexByZName(CString strZAxis);

	void AddRAxis(CString pStrAxis);
	bool RemoveRAxis(INT_PTR indx);
	INT_PTR GetRAxisCount();
	void AddAllRAxis();
	CString GetRAxisByIndex(INT_PTR indx);

	INT_PTR AddLinearIntpAxis(long Gantry);
	INT_PTR AddSomeRIntpAxis(SomeTarget Target);
	INT_PTR AddAllRIntpAxis();
	INT_PTR AddSomeZIntpAxis(SomeTarget Target);
	INT_PTR AddAllZIntpAxis();
	void InitMultiRatio();
	void InitMultiRatioR();

	void SetMultiRatio(double Ratio);
	void SetMultiRatio(SomeTarget Target);
	long SetMultiPosSet(double Inpos);
	long SetMultiPosSet(SomeTarget Target);
	long SetMultiDelayedPosSet(double Inpos, long Ms);
	long SetMultiDelayedPosSet(SomeTarget Target);

	void SetMultiRatioR(double Ratio);
	void SetMultiRatioR(SomeTarget Target);
	long SetMultiPosSetR(double Inpos);
	long SetMultiPosSetR(SomeTarget Target);
	long SetMultiDelayedPosSetR(double Inpos, long Ms);
	long SetMultiDelayedPosSetR(SomeTarget Target);

	long SetMultiCommand(long Gantry, SomeTarget Target);
	long SetMultiCommand(long Gantry, long Target, double x, double y);
	long SetMultiCommand(long Gantry, double pos);

	long SetMultiCommandR(long Gantry, SomeTarget Target);
	long SetMultiCommandR(long Gantry, long Target, double x, double y);
	long SetMultiCommandR(long Gantry, double pos);

	void RemoveLinearIntpAxis();
	void RemoveLinearIntpAxisR();
	long SendCameraRecognitionOffset(long Gantry);

	void SetHeadOffset(long HeadNo, Point_XY Offset);
	Point_XY GetHeadOffset(long HeadNo);
	Point_XY GetHMOffset();
	void SetCameraRecognitionPosition(long HeadNo, Point_XY Position);
	Point_XY GetCameraRecognitionPosition(long HeadNo);
	void SetCameraRecognitionOffset(long HeadNo, Point_XY Offset);
	Point_XY GetCameraRecognitionOffset(long HeadNo);
	void SetRearCameraRecognitionPosition(long HeadNo, Point_XY Position);
	Point_XY GetRearCameraRecognitionPosition(long HeadNo);
	void SetRearCameraRecognitionOffset(long HeadNo, Point_XY Offset);
	Point_XY GetRearCameraRecognitionOffset(long HeadNo);
	void SetGlobalDiscardPosition(Point_XYRZ Discard);
	Point_XYRZ GetGlobalDiscardPosition();
	void SetGlobalNozzleNo(long HeadNo, long NozzleNo);
	long GetGlobalNozzleNo(long HeadNo);
	void SetGlobalNozzleInformation(long StationNo, NOZZLE NozzleInfo);
	NOZZLE GetGlobalNozzleInformation(long StationNo);
	void SetGlobalTowerYellowLampTime(long YellowTowerLampTime);
	long GetGlobalTowerYellowLampTime();
	void SetGlobalEmptyBuzzerTime(long EmptyBuzzerTime);
	long GetGlobalEmptyBuzzerTime();
	void SetGlobalMachineReferenceMark(MachineReferenceMark MachineReferenceMark);
	MachineReferenceMark GetGlobalMachineReferenceMark();
	bool IsCameraCenterPositionByHeadNo(long HeadNo);
	bool IsCamera6CenterPositionByHeadNo(long HeadNo);
	long GetCameraChkPosByHead(long HeadNo);
	long GetCamera6ChkPosByHead(long HeadNo);
	long GetCameraNoByHead(long Gantry, long HeadNo);
	long GetCamera6NoByHead(long Gantry, long HeadNo);
	long GetCameraHeadFromHeadNo(long HeadNo);
	long GetCamera6HeadFromHeadNo(long HeadNo);

	void WriteHomePosition(CString strAxis, double HomePosition);
	double ReadHomePosition(CString strAxis);
	void WriteCameraAlignPosition(long Gantry, Point_XY CameraAlign);
	Point_XY ReadCameraAlignPosition(long Gantry);
	void WritePcbFixPosition(long Gantry, Point_XY PcbFix);
	Point_XY ReadPcbFixPosition(long Gantry);
	void WriteReferenceFeederPosition(long Gantry, long RefFdNo, Point_XY RefFdPos);
	Point_XY ReadReferenceFeederPosition(long Gantry);
	long ReadReferenceFeederNo(long Gantry);
	void WriteFeederPitch(long Gantry, double Pitch);
	double ReadFeederPitch(long Gantry);
	Point_XY ReadOriginDist(Point_XY Origin);
	Point_XY ReadMarkDist(Point_XY MarkPt, Point_XY Origin);
	Point_XY ReadInsertDist(Point_XY InsertPt, Point_XY Origin);
	Point_XY ReadOriginTarget(Point_XY Origin);
	Point_XY ReadMarkTarget(Point_XY MarkPt, Point_XY Origin, const bool& isSkipReadBlockTarget);//isSkipReadBlockTarget에 기본값 false 넣으려다가 호출하는곳이 딱 한개라 그냥 뺐다.
	Point_XY ReadInsertTarget(Point_XY InsertPt, Point_XY Origin);
	void WriteConfirmInsertBeforePosition(Point_XY Before);
	Point_XY ReadConfirmInsertBeforePosition();
	void WriteConfirmMeasureHeightBeforePosition(Point_XYT Before);
	Point_XYT ReadConfirmMeasureHeightBeforePosition();	
	long DisableZCompensation(CString strAxisZ);
	long EnableZCompensation(CString strAxisZ);
	long SetZCompensation(CString strAxisZ);
	void InitializeHeadMech();
	void InitializeHeadMech(long HeadNo);
	void InitializeCamPosMech();
	void InitializeCamOffsetMech();
	void InitializeRearCamPosMech();
	void InitializeRearCamOffsetMech();
	long CheckLimitOver(CString strAxis, double Command);
	long GetSuctionIONo(long Gantry, long HeadNo);
	long GetBlowIONo(long Gantry, long HeadNo);
	long SuctionOne(long Gantry, long HeadNo, bool bSuction);
	long BlowOne(long Gantry, long HeadNo, bool bBlow);
	long SuctionAll(long Gantry, bool bSuction);
	long BlowAll(long Gantry, bool bBlow);
	long SetOneSuction(long Gantry, long HeadNo, bool bSuction);
	bool GetOneSuction(long Gantry, long HeadNo);
	long SetOneBlow(long Gantry, long HeadNo, bool bBlow);
	bool GetOneBlow(long Gantry, long HeadNo);
	bool GetAllSuction(long Gantry);
	bool GetAllBlow(long Gantry);
	long CheckAirPressureLow();
	long CheckLinearMotorTemperatureHigh(long Gantry);
	void SaveValue();
	void LoadValue();
	long GetTorqueLimit(CString strAxis, double* TorqueLimit);
	long SetTorqueLimit(CString strAxis, double Torque);
	long SetEventToStopByOverTorque(long Eventid, CString strAxis, double Torque, double SaftyPosition);
	long SetEventToOverrideVelByPosition(long EventID, CString strAxis, double Position, double Ratio);
	long SetEventToStopByAreaSensor(long EventID, long AreaSensor, CString strAxis);
	long RemoveEvent(long EventID);
	long EnableEvent(long Eventid);
	long ClearAllEvent();
	long GetAllEventCount();
	bool GetEventAvailable(long Eventid);
	long StartWmx3Monitor(CString strAxis, long BoardCount, long BlockNo, long InsertNo, CString Action);
	bool WaitStopMonitor(CString strAxis);
	long ResetMonitor(CString strAxis);
	CString GetTorqueMonitorFileName(CString strAxis);
	long StopWmx3Monitor(CString strAxis);
	bool IsMoveOnceAxis(CString strAxis);
	void SetMoveOnceAxisRZ(bool Set);
	bool GetMoveOnceAxisRZ();
	void SetAxisPause(CString strAxis, bool Pause);
	bool GetAxisPause(CString strAxis);
	bool WaitAxisPauseState(long TimeOut);
	//bool WaitGantryPause(long Gantry, long TimeOut);
	//void SetGantryPause(long Gantry, bool Pause);
	void ResetAxisPause();
	void SetLockOKAxisName(CString strAxis);
	CString GetLockOKAxisName();
	bool IsAxisStatusJog(CString strAxis);

private:	
	void InitialNozzle();
	void InitialPosition();
	void InitializeHeightSensorMech();
	HANDLE GetThreadLock();
	bool Lock();
	bool Unlock();
	HANDLE m_CmdLock;

	long m_Table;
	double m_InsertByZ;
	double m_PusherByZ;
	double m_StandByZ;
	double m_StandByR;
	double m_DryRunZHeightOffset;
	double m_ZMaxTorqueLimit[MAXUSEDHEADNO];
	double m_Position[MAXGANTRYAXISNO];
	double m_ShortDist[MAX_SHORT_DIST_LEVEL];
	double m_ShortDistVel[MAX_SHORT_DIST_LEVEL];
	double m_ShortDistAccDec[MAX_SHORT_DIST_LEVEL];
	bool m_bPause[MAXGANTRYAXISNO];
	HANDLE m_MotionLock[MAXGANTRYAXISNO];
	bool m_bSuction[MAXUSEDHEADNO];
	bool m_bBlow[MAXUSEDHEADNO];
	bool m_bUseZAxis[MAXUSEDHEADNO];
	bool m_bUseRAxis[MAXUSEDHEADNO];
	bool m_bWriteDisk;
	Point_XY m_HeadOffset[MAXUSEDHEADNO];
	Point_XY m_HeightMeasurementOffset;
	Point_XY m_CameraRecogPosition[MAXUSEDHEADNO];
	Point_XY m_RearCameraRecogPosition[MAXUSEDHEADNO];
	Point_XY m_CameraRecogOffset[MAXUSEDHEADNO];
	Point_XY m_RearCameraRecogOffset[MAXUSEDHEADNO];
	Point_XY m_ConfirmInsertBeforePosition;
	Point_XYT m_ConfirmMeasureHeightBeforePosition;
	double m_OriginOffset[MAXGANTRYAXISNO];
	Limit m_Limit[MAXGANTRYAXISNO];
	CArray<CString, CString> m_ZaxisArray;
	CArray<CString, CString> m_RaxisArray;
	Point_XYRZ m_Discard;
	long m_GlobalNozzleNo[MAXUSEDHEADNO];
	NOZZLE m_MachineNozzle[MAXSTATIONNO];
	long m_GlobalYellowTowerLampTime;
	long m_GlobalEmptyBuzzerTime;
	MachineReferenceMark m_MachineReferenceMark;
	bool m_MoveOnceZREnable;
	CString m_LockOKAxis;

};

extern CPowerGantry* gcPowerGantry;
